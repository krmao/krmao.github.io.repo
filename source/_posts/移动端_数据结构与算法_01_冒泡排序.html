---
title: 移动端_IOS【数据结构与算法 01】冒泡排序
date: 2014年09月10日 10:37:04
categories: [技术]
tags: [移动端]
---

<link rel="stylesheet" href="https://csdnimg.cn/public/common/toolbar/content_toolbar_css/content_toolbar.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/vendor/pagination/paging.css">

<div class="htmledit_views" id="content_views">
                
<p>算法思想：</p>
<p></p>
<ul><li>一共进行 array.size-1趟排序，每一趟排序，都将左右两个数进行比较大小，并且交换位置，这样的效果是：每一趟排序中，能找到最大的值冒泡到该趟排序的最后面，这样的话，第一趟排序，最后一个数是最大的，第二趟排序，倒数第二个数就是第二大的，最后一趟排序后 (因为最后一趟只有一个数，不用比较，所以比较次数是 array.size-1 趟)，将得到有序数组</li></ul><p></p>
<p><strong><a href="http://blog.csdn.net/mkrcpp/article/details/39178213" rel="nofollow">博客地址：http://blog.csdn.net/mkrcpp/article/details/39178213</a></strong></p>
<p></p><pre><code class="language-java">import java.util.Arrays;

/***
 * @title 冒泡排序
 * @author michael.mao
 * @date 2014年9月10日 上午10:00:44
 * @version V1.0
 */
public class BubbleSort
{
	/***
	 * @title 一共进行 array.size-1趟排序，每一趟排序，都将左右两个数进行比较大小，并且交换位置，这样的效果是：每一趟排序中，
	 *        能找到最大的值冒泡到该趟排序的最后面，这样的话，第一趟排序，最后一个数是最大的，第二趟排序，倒数第二个数就是第二大的，最后一趟排序后
	 *        (因为最后一趟只有一个数，不用比较，所以比较次数是 array.size-1 趟)，将得到有序数组
	 * @param array
	 * @author michael.mao
	 * @date 2014年9月10日 上午10:28:00
	 * @version V1.0
	 */
	public static void execute(int[] array)
	{
		int tmp = 0;
		// 如果一次循环后发现没有交换，说明数组有序，无需排序
		boolean isSwap = true;
		for (int i = 0; ((i &lt; array.length - 1) &amp;&amp; isSwap); i++)
		{
			isSwap = false;
			for (int j = 0; j &lt; array.length - 1 - i; j++)
			{
				if ( array[j] &gt; array[j + 1] )
				{
					tmp = array[j + 1];
					array[j + 1] = array[j];
					array[j] = tmp;
					isSwap = true;
				}
			}
		}
	}

	// 循环测试次数
	public static int LOOP_COUNT = 100;
	public static int ARRAY_SIZE = 10000;

	public static void main(String[] args)
	{
		int[] mArray = Common.getArray(ARRAY_SIZE);
		int allTime = 0;
		for (int i = 0; i &lt; LOOP_COUNT; i++)
		{
			// 拷贝数组
			int[] tmpArray = Arrays.copyOf(mArray, ARRAY_SIZE);
			long tmpTime = System.currentTimeMillis();
			execute(tmpArray);
			allTime += System.currentTimeMillis() - tmpTime;
		}
		System.err.println("数组大小为(" + ARRAY_SIZE + ")的" + LOOP_COUNT + "次冒泡排序的平均耗时为：" + allTime / (float) LOOP_COUNT);
	}
}
</code></pre>
<p><br></p>
<p></p><pre><code class="language-java">数组大小为(10000)的100次冒泡排序的平均耗时为：125.79 ms
</code></pre><br><br><p><br></p>
<br><br>            </div>

